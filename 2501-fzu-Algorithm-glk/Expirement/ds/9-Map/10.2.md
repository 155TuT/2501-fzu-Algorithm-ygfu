# 10.2 图论难题

## 问题描述

数据结构与算法课程里面有各种求解最短路的算法，比如floyd算法、dijkstra算法、bellman算法。但该难题需要求解的不是最短路，而是求最短路的路径条数。

## 实验任务

我们定义从source到达target的路径：source→u→v→target是最短路，当且仅当该路径里面的所有边（u，v）满足：存在一条从v出发到终点的路径长度小于任意一条从u出发到终点的路径长度。

对于给定的一个无向无自环的图给你一个起点和一个终点，求出从起点到终点的最短路的路径条数。

## 数据输入

第一行有两个正整数N(1<=N<=1000),M(0<=M<=(N-1)*N/2)。N代表图G的顶点个数,M代表图G有M条边。

接下来一共有M 条边的描述， 每条边的描述有三个整数u(1<=u<=N),v(1<=v<=N),len(1<=len<=1000)。代表从u点到v点有一条边，且边的长度为len。数据保证u!=v且不会出现重边。

最后一行有两个整数S(1<=S<=N),T(1<=T<=N)。分别表示起点和终点。

## 数据输出

输出一行为从S到T的最短路长度，如果S根本就走不到T就输出-1

## 输入示例

```cpp
4 4
1 4 5
1 3 3
2 3 10
2 4 10
1 2
```

## 输出示例

```cpp
2
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int INF = 0x3f3f3f3f;
const int MAXN = 1005;

struct Edge {
    int to;
    int w;
};

int N, M;
vector<Edge> g[MAXN];
int S, T;
int dista[MAXN];
bool vis[MAXN];
ll dp[MAXN];

void dijkstra(int s) {
    for (int i = 1; i <= N; i++) {
        dista[i] = INF;
        vis[i] = false;
    }
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    dista[s] = 0;
    pq.push({0, s});
    while (!pq.empty()) {
        auto cur = pq.top();
        pq.pop();
        int d = cur.first;
        int u = cur.second;
        if (vis[u]) continue;
        vis[u] = true;
        for (auto &e : g[u]) {
            int v = e.to;
            int w = e.w;
            if (!vis[v] && dista[v] > d + w) {
                dista[v] = d + w;
                pq.push({dista[v], v});
            }
        }
    }
}

ll dfs(int u) {
    if (dp[u] != -1) return dp[u];
    if (u == S) return dp[u] = 1;
    ll ans = 0;
    for (auto &e : g[u]) {
        int v = e.to;
        if (dista[v] > dista[u]) ans += dfs(v);
    }
    dp[u] = ans;
    return ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    if (!(cin >> N >> M)) return 0;
    for (int i = 1; i <= N; i++) g[i].clear();

    for (int i = 0; i < M; i++) {
        int u, v, len;
        cin >> u >> v >> len;
        g[u].push_back({v, len});
        g[v].push_back({u, len});
    }
    cin >> S >> T;

    dijkstra(T);

    if (dista[S] == INF) {
        cout << -1 << '\n';
        return 0;
    }

    for (int i = 1; i <= N; i++) dp[i] = -1;

    cout << dfs(T) << '\n';

    return 0;
}
```

[返回目录](../README.md)
