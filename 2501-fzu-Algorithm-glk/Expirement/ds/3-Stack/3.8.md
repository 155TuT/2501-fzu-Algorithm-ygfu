# 3.8 价值

## 实验任务

K 神最近喜欢上了刷题，一天不刷浑身难受。最近他研究发现，自己的人生价值在于他某段时间内的刷题总数乘上这几天刷题数的最小值，现在 K 神很寂寞（无敌是多么寂寞），想知道他人生价值最高的时候究竟有多高（krz）

## 数据输入

第一行为总天数 N(1<=N<=100000)

接下来一行 N 个整数 ai（1<=ai<=100000），表示 K 神第 i 天的刷题数。

## 数据输出

输出 K 神在连续一段时间内可能的最高价值 W。

## 输入示例

```cpp
6
3 1 6 4 5 2
```

## 输出示例

```cpp
60
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    if (!(cin >> N)) return 0;
    vector<ll> a(N + 1), pre(N + 1);
    for (int i = 1; i <= N; i++) {
        cin >> a[i];
        pre[i] = pre[i - 1] + a[i];
    }

    vector<int> L(N + 1), R(N + 1);
    stack<int> st;

    for (int i = 1; i <= N; i++) {
        while (!st.empty() && a[st.top()] >= a[i]) st.pop();
        L[i] = st.empty() ? 0 : st.top();
        st.push(i);
    }

    while (!st.empty()) st.pop();

    for (int i = N; i >= 1; i--) {
        while (!st.empty() && a[st.top()] >= a[i]) st.pop();
        R[i] = st.empty() ? N + 1 : st.top();
        st.push(i);
    }

    ll ans = 0;
    for (int i = 1; i <= N; i++) {
        ll sum = pre[R[i] - 1] - pre[L[i]];
        ll val = sum * a[i];
        if (val > ans) ans = val;
    }

    cout << ans << '\n';

    return 0;
}
```

[返回目录](../README.md)
