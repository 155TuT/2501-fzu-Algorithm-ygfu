# 5.28 Just Sort

## 实验任务

定两个序列 a b，序列 a 原先是一个单调递增的正数序列，但是由于某些 原因，使得序列乱序了，并且一些数丢失了（用 0 表示）。经过数据恢复后，找 到了正数序列 b ，且序列 a 中 0 的个数等于序列 b 的个数，打算使用序列 b 恢 复序列 a 。

对于序列 a 来说，我们可以交换两个位置上的非零的数，并且可以交换任意次。序列 b 同样也可以进行任意次交换。

现在要将序列 b 填充到序列 a 中的值丢失的位置上，序列 b 中的每个数只能填充一次，问最后构成的序列是否是单调递增的，如果是，则输出填充后的序列， 否则输出-1。

## 数据输入

输入给定 N M，表示序列 a 和序列 b 的长度。

第一行为序列 a ，第二行为 序列 b。 题目保证除了 0 以外的数，在序列 a 和 b 中只出现一次。

数据保证:

80%的数据，N, M <= 100

100%的数据，N, M <= 100000, 0 <= a[i] <= 100000, 0 < b[i] <= 100000

## 数据输出

如果最后序列 a 是单调递增的，输出该序列，否则输出-1。

## 输入示例1

```cpp
4 2
0 11 0 15 
1 12 
```

## 输出示例 1

```cpp
1 11 12 15 
```

## 输入示例2

```cpp
4 2 
0 0 11 15 
1 12 
```

## 输出示例 2

```cpp
-1
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, M;
    if (!(cin >> N >> M)) return 0;
    vector<ll> a(N), b(M);
    for (int i = 0; i < N; i++) cin >> a[i];
    for (int i = 0; i < M; i++) cin >> b[i];

    vector<int> isApos(N);
    for (int i = 0; i < N; i++) {
        if (a[i] != 0) isApos[i] = 1;
    }

    vector<pair<ll,int>> v;
    v.reserve(N);
    for (int i = 0; i < N; i++) {
        if (a[i] != 0) v.push_back({a[i], 0});
    }
    for (int i = 0; i < M; i++) {
        v.push_back({b[i], 1});
    }

    if ((int)v.size() != N) {
        cout << -1 << '\n';
        return 0;
    }

    sort(v.begin(), v.end());

    for (int i = 0; i < N; i++) {
        int t = v[i].second;
        if (isApos[i]) {
            if (t != 0) {
                cout << -1 << '\n';
                return 0;
            }
        } else {
            if (t != 1) {
                cout << -1 << '\n';
                return 0;
            }
        }
    }

    for (int i = 0; i < N; i++) {
        if (i) cout << ' ';
        cout << v[i].first;
    }
    cout << '\n';

    return 0;
}
```

[返回目录](../README.md)
