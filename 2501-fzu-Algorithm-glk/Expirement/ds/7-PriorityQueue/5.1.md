# 5.1 Huffuman树问题

## 问题描述

对于给定的一个数列，求出用该数列构造Huffman树的总费用。

给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下：

1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后**将它们的和加入到{pi}**中。这个过程的费用记为pa + pb。
2. 重复步骤1，直到{pi}中只剩下一个数。

在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。

例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：

- 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。
- 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。
- 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。
- 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。

现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。

## 数据输入

输入的第一行包含一个正整数n（n<=100）。

接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。

## 数据输出

用这些数构造Huffman树的总费用。

## 输入示例

```cpp
5
5 3 8 2 9
```

## 输出示例

```cpp
59
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n;
    if (!(cin >> n)) return 0;

    priority_queue<ll, vector<ll>, greater<ll> > pq;
    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x;
        pq.push(x);
    }

    ll ans = 0;
    while (pq.size() > 1) {
        ll a = pq.top(); pq.pop();
        ll b = pq.top(); pq.pop();
        ans += a + b;
        pq.push(a + b);
    }

    cout << ans << '\n';
    return 0;
}
```

[返回目录](../README.md)
