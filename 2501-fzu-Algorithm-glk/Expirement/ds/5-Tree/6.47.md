# 6.47 鼹鼠报数

## 实验任务

Winder 养了一群会报数的鼹鼠，而且Winder喜欢用数字给他的鼹鼠们编号，如“311”、“1048”等。当然，为了不混淆，鼹鼠们的编号都是不同的。为了锻炼鼹鼠们的身体健康，Winder决定让鼹鼠们进行掘土训练，顺便提高鼹鼠们的挖掘能力。

鼹鼠们排成一列，由第一个开始向下挖洞，并待在洞中。第二只与第一只相比，若编号值大的鼹鼠，则向右下方挖洞，否则向左下方。接下来的鼹鼠们以此类推，若比洞中所在鼹鼠编号值大，则向右下方走，否则向左下方。

训练结束后，Winder会让他的鼹鼠们报数（既报出各自的编号）。通过报数的序列Winder想知道经过训练之后，鼹鼠们的位置是怎样的。

报数规则为：如果A鼹鼠的下方分别存在ALeft鼹鼠和ARight鼹鼠，则ALeft鼹鼠在ARight鼹鼠之前报数，ARight鼹鼠在A鼹鼠之前报数。

位置表达式规则为：“根节点<左子树表达式><右子树表达式>”,如左子树不存在,则只输出“根节点<右子树表达式>”，右子树同理。

```txt
  3
 / \
2   5
   / \
  4   7
```

例如上图，报数顺序为2，4，7，5，3可以表示为 3<2><5<4><7>>

## 数据输入

第一行为N（2 < N <= 1000），表示有N只鼹鼠。
第二行为N个整数bi（0 < bi < 10000），表示报数顺序。

## 数据输出

输出鼹鼠们的位置表达式。

## 输入示例

```cpp
5
2 4 7 5 3
```

## 输出示例

```cpp
3<2><5<4><7>>
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Node {
    int v, l, r;
};

vector<int> a;
vector<Node> t;

int build(int l, int r) {
    if (l > r) return -1;
    int root = a[r];
    int mid = l;
    while (mid < r && a[mid] < root) mid++;
    int id = (int)t.size();
    t.push_back({root, -1, -1});
    int L = build(l, mid - 1);
    int R = build(mid, r - 1);
    t[id].l = L;
    t[id].r = R;
    return id;
}

void print(int u) {
    cout << t[u].v;
    if (t[u].l != -1) { cout << '<'; print(t[u].l); cout << '>'; }
    if (t[u].r != -1) { cout << '<'; print(t[u].r); cout << '>'; }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N; 
    if (!(cin >> N)) return 0;
    a.resize(N);
    for (int i = 0; i < N; i++) cin >> a[i];

    t.reserve(N);
    int root = build(0, N - 1);
    if (root != -1) print(root);
    cout << '\n';
    return 0;
}
```

[返回目录](../README.md)
