# 6.41 文件管理器

## 背景

操作系统具有对计算机硬件资源管理和调度的功能。文件是对占用了硬盘一定空间的对象的描述和抽象。考虑一般的文件具有文件名、大小和创建时间。文件管理在任何操作系统中都是必不可少的。文件管理器是用户用来观察和操作文件的一个软件。考虑一个简易的文件管理器，用户可以通过这个简易的文件管理器对某个目录下文件最大/小、文件名(字符串)字典序最大/最小的一些文件，即按XX排序功能，此外文件管理器具有删除和添加文件的功能。输入保证目录只有一级，操作随机。

## 输入及输出格式

第1行输入一个Q(1<=Q<=100000)，表示操作的次数。

第2-Q+1行输入一行操作序列

操作序列的格式为 op args

- 当op=1,即第一种操作时，args的格式为 folder name size 表示将要在某个folder目录(1<=folder<=5的整数)下添加文件名为name(1<=name<=100000的整数)的文件，文件大小为size(1<=size<=100000的整数)，如果文件名重复，就先删除原来的文件再进行1操作；
- 当op=2,即第二种操作时，args的格式为 folder name表示将要在某个folder目录(1<=folder<=5的整数)下删除文件名为name(1<=name<=100000的整数)的文件，如果文件名不存在，操作不执行；
- 当op=3,即第三种操作时，args的格式为 folder k 表示输出某个目录下文件大小最大至第k大的文件名，如果大小相同按文件名数字从小到大输出，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；
- 当op=4,即第四种操作时，args的格式为 folder k 表示输出某个目录下文件名数字大小最小至第k小的文件名，如果不满k个文件只需要输出已有的文件名，如果文件夹为空或不存在则输出一个空行；

保证1<= k <=10

## 备注

输出文件名以空格隔开，不输出多余的换行和空格

## 输入示例

```cpp
10
2 3 74071
3 1 2
3 2 8
2 3 71337
3 3 7
3 2 7
4 2 10
4 3 6
4 3 4
3 1 4
```

## 输出示例

```cpp








```

上方输出8个空行

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Cmp {
    bool operator()(const pair<int,int> &a, const pair<int,int> &b) const {
        if (a.first != b.first) return a.first > b.first;
        return a.second < b.second;
    }
};

struct Folder {
    map<int,int> byName;
    set<pair<int,int>, Cmp> bySize;
};

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int Q;
    if (!(cin >> Q)) return 0;
    vector<Folder> f(6);

    for (int i = 0; i < Q; i++) {
        int op; cin >> op;
        if (op == 1) {
            int folder, name, size; cin >> folder >> name >> size;
            auto &F = f[folder];
            auto it = F.byName.find(name);
            if (it != F.byName.end()) {
                F.bySize.erase({it->second, name});
                F.byName.erase(it);
            }
            F.byName[name] = size;
            F.bySize.insert({size, name});
        } else if (op == 2) {
            int folder, name; cin >> folder >> name;
            auto &F = f[folder];
            auto it = F.byName.find(name);
            if (it != F.byName.end()) {
                F.bySize.erase({it->second, name});
                F.byName.erase(it);
            }
        } else if (op == 3) {
            int folder, k; cin >> folder >> k;
            auto &F = f[folder];
            vector<int> out;
            int cnt = 0;
            for (auto it = F.bySize.begin(); it != F.bySize.end() && cnt < k; it++, cnt++) {
                out.push_back(it->second);
            }
            for (int j = 0; j < (int)out.size(); j++) {
                if (j) cout << ' ';
                cout << out[j];
            }
            cout << '\n';
        } else if (op == 4) {
            int folder, k; cin >> folder >> k;
            auto &F = f[folder];
            vector<int> out;
            int cnt = 0;
            for (auto it = F.byName.begin(); it != F.byName.end() && cnt < k; it++, cnt++) {
                out.push_back(it->first);
            }
            for (int j = 0; j < (int)out.size(); j++) {
                if (j) cout << ' ';
                cout << out[j];
            }
            cout << '\n';
        }
    }
    return 0;
}
```

[返回目录](../README.md)
