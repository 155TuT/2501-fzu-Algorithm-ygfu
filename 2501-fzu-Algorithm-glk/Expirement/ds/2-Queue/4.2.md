# 4.2 Rescue the princess

## 实验任务

有一天，公主被一个魔王抓走关在一个城堡里面，城堡可以用 N*M 的矩阵来描述，1<N,M<=200。监狱由 N*M 个方格组成，每个方格中可能为墙壁，空地，怪物，公主或者是勇士。

现在勇士想去营救公主。他的任务是找到公主。约定，“找到公主”的意思是到达公主被关的位置。如果勇士想到达某个方格，但方格中有怪物，那么必须杀死怪物，才能到达这个方格。假设勇士只能向上，下，左，右四个方向移动一步。移动一步的需要花费 1 个单位的时间，杀死怪物也需要一个单位的时间。

试着计算勇士找到公主需要多长时间。只能上，下，左，右移动，而且墙壁不能通过。

## 数据输入

输入第一行包含 2 个整数 N，M，接下来 N 行，每行 M 个字符：“.”代表空地，“a”表示公主，“r”表示勇士，“#”代表墙壁，“x”表示怪物。（测试数据中“a”和“r”只有一个）。

## 数据输出

输出一个整数，表示找到公主所需要最短的时间。如果无法找到公主，输出-1。

## 输入示例

```cpp
7 8
#.#####.
#.a#..r.
#..#x...
..#..#.#
#...##..
.#......
........
```

## 输出示例

```cpp
13
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, M;
    if (!(cin >> N >> M)) return 0;
    vector<string> g(N);
    for (int i = 0; i < N; i++) cin >> g[i];

    int sx = -1, sy = -1, tx = -1, ty = -1;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++) {
            if (g[i][j] == 'r') { sx = i; sy = j; }
            else if (g[i][j] == 'a') { tx = i; ty = j; }
        }

    const int INF = 1e9;
    vector<int> dist(N * M, INF);

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    int start = sx * M + sy;
    int target = tx * M + ty;
    dist[start] = 0;
    pq.push(make_pair(0, start));

    int dx[4]={-1, 1, 0, 0}, dy[4]={0, 0, -1, 1};
    while(!pq.empty()){
        pair<int,int> top = pq.top(); pq.pop();
        int d = top.first, u = top.second;
        if (d != dist[u]) continue;
        int x = u / M, y = u % M;
        if (u == target) break;
        for (int k = 0; k < 4; k++) {
            int nx = x + dx[k], ny = y + dy[k];
            if (nx < 0 || nx >= N || ny < 0 || ny >= M) continue;
            if (g[nx][ny] == '#') continue;
            int w = 1 + (g[nx][ny] == 'x');
            int v = nx * M + ny;
            if (dist[v] > d + w) {
                dist[v] = d + w;
                pq.push(make_pair(dist[v], v));
            }
        }
    }

    int ans = dist[target];
    cout << (ans >= INF ? -1 : ans) << '\n';
    return 0;
}
```

[返回目录](../README.md)
