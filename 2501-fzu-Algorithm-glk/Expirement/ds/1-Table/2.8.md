# 2.8 洗盘子

## 实验任务

猪妈妈有很多小猪仔，每次吃完饭洗盘子是一个很大的问题。这天猪妈妈想出了一个方法。她让小猪们排成一队，从 2 开始给他们编号。每次排在最前面的不用洗盘子（假设它的编号是 i ），但是，排在它后面的第 i 只 ，2*i 只，3*i 只…的小猪要洗盘子。让排在最前面以及要洗盘子的小猪出队，然后重复上述过程。那些不用洗盘子的小猪被称为幸运猪（lucky pigs），把它们的编号从小到大排序，现在要问第 n 个幸运猪的编号是多少。

比如说一开始，在最前面的小猪编号是 2，那么它不用洗盘子，出队。在它后面的第 2 只小猪，就是编号为 4 的小猪要洗盘子，编号为 6,8,10…的小猪都要洗盘子，然后它们都出队。其中编号为 2 的小猪就是第一只幸运猪了。接下排在最前面的小猪编号是 3，它是幸运猪，出队。在它后面的第 3 只，就是编号为 9 的小猪要洗盘子，出队。以此类推。

## 数据输入

输入第一行为 T ，代表接下去有 T 个询问， 0 < T < =300

接下去有 T 行，每行一个数 n ，0 < n < =3000

## 数据输出

对于每个询问输出一行，为第 n 个幸运猪的编号。

## 输入示例

```cpp
4
1
2
10
20
```

## 输出示例

```cpp
2
3
29
83
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

vector<int> lucky_up_to(int need) {
    int limit = max(10, need * 50);
    while (true) {
        vector<int> L; L.reserve(limit - 1);
        for (int x = 2; x <= limit; x++) L.push_back(x);
        for (size_t k = 0; k < L.size(); k++) {
            int s = L[k];
            if (s <= 1) break;
            if ((size_t)k + (size_t)s >= L.size() + 1) continue;
            vector<int> nxt; nxt.reserve(L.size());
            for (size_t j = 0; j < L.size(); j++) {
                if (j <= k) nxt.push_back(L[j]);
                else if (((j - k) % s) != 0) nxt.push_back(L[j]);
            }
            L.swap(nxt);
        }
        if ((int)L.size() >= need) return L;
        limit *= 2;
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int T; 
    if (!(cin >> T)) return 0;
    vector<int> qs(T);
    int mx = 0;
    for (int i = 0; i < T; i++) { cin >> qs[i]; mx = max(mx, qs[i]); }

    vector<int> L = lucky_up_to(mx);
    for (int n : qs) cout << L[n - 1] << '\n';
    return 0;
}
```

[返回目录](../README.md)
