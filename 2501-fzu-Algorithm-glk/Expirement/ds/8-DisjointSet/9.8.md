# 9.8 �?��炸弹

## 实验任务

A国有 N个城市，这些城市编号为 1到 N，有一天，他们调查出恐怖分子在每个城市中都安放了炸弹，于是他们给炸弹也编上了序号，第 i 个城市里的炸弹编号为 i。现在他们想把这些炸弹转移，以便于销毁炸弹。

由于炸弹是通过不同人转移的，所以需要一个指挥部门来记录转移炸弹的信息，以便于有些人要查询这些信息。我们有两个操作：

1. 将 a 炸弹目前所在城市中所有的炸弹转移到 b 炸弹所在的城市。
2. 询问 a 炸弹目前在哪个城市编号和这个城市中有炸弹个数。

## 数据输入

输入第一行包含两个数 N,Q（1<=N<=500000 , 1<=Q<=120000）。分别表示城市的个数和操作数。

接下来有 Q 行，每行表示一个操作，第一种操作输入格式为 1 a b，第二种操作输入格式为 2 a。（1<=a,b<=N）

## 数据输出

对于第一个操作，如果两个炸弹在同一个城市里，输出“ERROR”，并不执行此操作。否则执行操作并不输出任何东西。

对于第二种操作，输出一行两个数表示炸弹所在的城市编号和该城市中炸弹个数，用一个空格分开。

## 输入示例1

```cpp
3 3
1 1 2
1 3 2
2 2
```

## 输出示例1

```cpp
2 3
```

## 输入示例2

```cpp
3 5
1 1 2
1 2 1
2 1
1 1 3
2 1
```

## 输出示例2

```cpp
ERROR
2 2
3 3
```

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, Q;
    if (!(cin >> N >> Q)) return 0;

    vector<int> parent(N + 1), sz(N + 1), city(N + 1);
    for (int i = 1; i <= N; i++) {
        parent[i] = i;
        sz[i] = 1;
        city[i] = i;
    }

    function<int(int)> findp = [&](int x) {
        if (parent[x] == x) return x;
        return parent[x] = findp(parent[x]);
    };

    while (Q--) {
        int op;
        cin >> op;
        if (op == 1) {
            int a, b;
            cin >> a >> b;
            int ra = findp(a);
            int rb = findp(b);
            if (ra == rb) {
                cout << "ERROR" << '\n';
                continue;
            }
            int cityb = city[rb];
            if (sz[ra] > sz[rb]) swap(ra, rb);
            parent[ra] = rb;
            sz[rb] += sz[ra];
            city[rb] = cityb;
        } else if (op == 2) {
            int a;
            cin >> a;
            int r = findp(a);
            cout << city[r] << ' ' << sz[r] << '\n';
        }
    }

    return 0;
}
```

[返回目录](../README.md)
