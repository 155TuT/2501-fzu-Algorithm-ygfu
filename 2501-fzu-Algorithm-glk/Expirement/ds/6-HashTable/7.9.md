# 7.9 特殊匹配R

## 实验任务

定义一种语言L，L语言中所有的字符串只能由abc三个字母组成。
在语言L之上定义一种特殊匹配规则R，R的定义如下：假设有两个字符串x和y，x和y等长，且x与y有且只有一个位置上的字符不同。
例如字符串x为“abc”：

1. 若字符串y为”abb”，这x与y符合R匹配；
2. 若y为”abc”或”bbb”或”abcc”，则x与y不符合R匹配。

现给定一个由n个x字符串构成的匹配表r，然后进行m次询问。每次询问输入一个y字符串，然后判断r表中是否存在与y符合R匹配的x字符串，若有输出”YES”，否则输出”NO”。

## 数据输入

输入中第一行给出一整数n，m（1<=n,m<=1000）。
接下来n行给出n个x字符串。
接下来m行，每行输入一个y字符串进行询问。
题目保证每一个字符串的长度在1000以内。

## 数据输出

对于m个询问，每个询问输出在x个字符串中是否有与y字符串符合R匹配的字符串，若有输出”YES”，否则输出”NO”。

## 输入示例

```cpp
2 3
bbbbb
bcbcbcb
bbabb
ccbcbcc
cbbbc
```

## 输出示例

```cpp
YES
NO
NO
```

## 提示

60%的数据n<=100,m<=100
100%的数据n<=1000,m<=1000

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Key {
    unsigned long long h1, h2;
    bool operator==(const Key& o) const { return h1==o.h1 && h2==o.h2; }
};
struct KeyHash {
    size_t operator()(const Key& k) const {
        return k.h1 ^ (k.h2 + 0x9e3779b97f4a7c15ULL + (k.h1<<6) + (k.h1>>2));
    }
};

int code(char c){ return c=='a'?1:(c=='b'?2:3); }

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n,m;
    if(!(cin>>n>>m)) return 0;
    unordered_map<int, unordered_set<Key,KeyHash>> dict;
    const unsigned long long B1 = 1469598103934665603ULL, B2 = 1099511628211ULL;
    static unsigned long long p1[1005], p2[1005];
    p1[0]=1; p2[0]=1;
    for(int i=1;i<1005;i++){ p1[i]=p1[i-1]*B1; p2[i]=p2[i-1]*B2; }

    for(int i=0;i<n;i++){
        string s; cin>>s;
        int L=s.size();
        unsigned long long h1=0, h2=0;
        for(int j=0;j<L;j++){
            int v=code(s[j]);
            h1 += (unsigned long long)v * p1[L-1-j];
            h2 += (unsigned long long)v * p2[L-1-j];
        }
        dict[L].insert({h1,h2});
    }

    for(int qi=0;qi<m;qi++){
        string y; cin>>y;
        int L=y.size();
        if(!dict.count(L)){ cout<<"NO\n"; continue; }
        unsigned long long h1=0,h2=0;
        for(int j=0;j<L;j++){
            int v=code(y[j]);
            h1 += (unsigned long long)v * p1[L-1-j];
            h2 += (unsigned long long)v * p2[L-1-j];
        }
        bool ok=false;
        for(int i=0;i<L && !ok;i++){
            int v=code(y[i]);
            unsigned long long base1 = p1[L-1-i], base2 = p2[L-1-i];
            for(int c=1;c<=3;c++){
                if(c==v) continue;
                unsigned long long nh1 = h1 - (unsigned long long)v*base1 + (unsigned long long)c*base1;
                unsigned long long nh2 = h2 - (unsigned long long)v*base2 + (unsigned long long)c*base2;
                if(dict[L].count({nh1,nh2})){ ok=true; break; }
            }
        }
        cout<<(ok?"YES":"NO")<<'\n';
    }
    return 0;
}
```

[返回目录](../README.md)
